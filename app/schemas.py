"""
schemas.py
----------
Single Responsibility: Define Pydantic v2 models for the API contract.

These schemas act as the border patrol for the API. They control exactly
what JSON comes IN (validation) and what JSON goes OUT (serialization).

For Story 1, we define three schemas:
  - SpecialtyBase  : Shared foundation (name, description)
  - SpecialtyCreate: For incoming POST request bodies
  - SpecialtyOut   : For outgoing API responses
"""

from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional
from datetime import datetime


# ============================================================================
# 1. THE FOUNDATION
# ============================================================================
class SpecialtyBase(BaseModel):
    """
    Shared fields used by both input and output schemas.

    Why a base class?
    DRY (Don't Repeat Yourself). The `name` and `description` fields exist
    on both the input (what the client sends) and the output (what we send back).
    Instead of typing them out twice and risking them getting out of sync,
    we define them once here and inherit them.
    """

    # name: required, must be a string, at least 2 chars
    name: str = Field(
        ...,
        min_length=2,
        max_length=100,
        description="Name of the medical specialty (e.g. Cardiology)",
        examples=["Cardiology"],
    )

    # description: optional, defaults to None
    description: Optional[str] = Field(
        default=None,
        description="Optional detailed description",
        examples=["Complete care of the heart"],
    )


# ============================================================================
# 2. THE INPUT CONTRACT
# ============================================================================
class SpecialtyCreate(SpecialtyBase):
    """
    Schema exclusively for POST /specialties incoming JSON bodies.
    Inherits `name` and `description` from SpecialtyBase.
    Notice it does NOT have an `id` field â€” the client doesn't dictate the ID.
    """

    @field_validator("name")
    @classmethod
    def name_must_not_be_blank(cls, value: str) -> str:
        """
        Pydantic v2 Field Validator.
        This runs automatically before the JSON is accepted.
        value: str represents the incoming string for the 'name' field.
        """
        # .strip() removes leading/trailing spaces, tabs, and newlines
        if not value.strip():
            raise ValueError("Specialty name cannot be empty or just whitespace.")
        return value.strip()


# ============================================================================
# 3. THE OUTPUT CONTRACT
# ============================================================================
class SpecialtyOut(SpecialtyBase):
    """
    Schema exclusively for outgoing JSON API responses.
    Inherits `name` and `description` from SpecialtyBase.
    Adds the `id` field, which was generated by the database.
    """

    id: int = Field(description="Auto-generated unique database ID")
    created_at: datetime = Field(description="Timestamp of creation")

    # ------------------------------------------------------------------
    # What does from_attributes=True do?
    # ------------------------------------------------------------------
    # By default, Pydantic expects data as a Python dictionary:
    #   data = {"id": 1, "name": "Cardio"}
    #   SpecialtyOut(**data)  <-- Works!
    #
    # However, SQLAlchemy returns full ORM OBJECTS, not dictionaries:
    #   obj = crud.get_specialty()
    #   # obj.id == 1, obj.name == "Cardio"
    #
    # FastAPI tries to feed the SQLAlchemy object into the Pydantic schema.
    # Without from_attributes=True, Pydantic crashes saying "I need a dict!"
    # With from_attributes=True, Pydantic knows to say:
    # "Oh, it's an object? I'll look for obj.id and obj.name instead of obj['id']"
    # ------------------------------------------------------------------
    model_config = ConfigDict(from_attributes=True)
